<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Compass (圆规)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            margin: 0 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Interactive Compass (圆规)</h3>
        <p>操作说明:</p>
        <ul>
            <li>鼠标左键 + 拖动: 移动整个场景视角</li>
            <li>鼠标右键 + 拖动: 移动圆规位置</li>
            <li>鼠标滚轮: 调整圆规张开角度 (圆的半径)</li>
            <li>"画圆"模式下, 左键拖动画圆</li>
        </ul>
        <div>圆规角度: <span id="angle">30</span>°</div>
        <div>圆半径: <span id="radius">2.0</span></div>
    </div>
    <div id="controls">
        <button id="toggle-mode">模式: 移动圆规</button>
        <button id="reset">重置画布</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 10);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // OrbitControls for camera movement
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.25;
        orbitControls.screenSpacePanning = false;
        orbitControls.maxPolarAngle = Math.PI / 2;
        orbitControls.enabled = true;
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        scene.add(directionalLight);
        
        // Create drawing plane
        const planeGeometry = new THREE.PlaneGeometry(20, 20);
        const planeMaterial = new THREE.MeshLambertMaterial({ 
            color: 0xffffff,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true; // Keep plane receiving shadows
        scene.add(plane);
        
        // Add grid helper for reference
        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);
        
        // Create the compass
        const compassGroup = new THREE.Group();
        scene.add(compassGroup);
        
        // Compass pivot at the top
        const pivotGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const pivotMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const pivot = new THREE.Mesh(pivotGeometry, pivotMaterial);
        pivot.position.y = 3;
        pivot.castShadow = false; // Remove shadow as requested
        compassGroup.add(pivot);
        
        // Create two leg groups that will rotate from the pivot
        const needleLegGroup = new THREE.Group();
        const pencilLegGroup = new THREE.Group();
        
        // Position the leg groups at the pivot
        needleLegGroup.position.y = 3;
        pencilLegGroup.position.y = 3;
        
        compassGroup.add(needleLegGroup);
        compassGroup.add(pencilLegGroup);
        
        // Needle leg
        const needleLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
        const legMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
        const needleLeg = new THREE.Mesh(needleLegGeometry, legMaterial);
        needleLeg.position.y = -1.5;
        needleLeg.castShadow = false; // Remove shadow as requested
        needleLegGroup.add(needleLeg);
        
        // Needle point
        const needlePointGeometry = new THREE.ConeGeometry(0.08, 0.2, 16);
        const needlePointMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const needlePoint = new THREE.Mesh(needlePointGeometry, needlePointMaterial);
        needlePoint.position.y = -3;
        needlePoint.rotation.x = Math.PI; // Point down
        needlePoint.castShadow = false; // Remove shadow as requested
        needleLegGroup.add(needlePoint);
        
        // Pencil leg
        const pencilLegGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
        const pencilLeg = new THREE.Mesh(pencilLegGeometry, legMaterial);
        pencilLeg.position.y = -1.5;
        pencilLeg.castShadow = false; // Remove shadow as requested
        pencilLegGroup.add(pencilLeg);
        
        // Improved pencil tip
        const pencilBodyGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
        const pencilBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 }); // Wood color
        const pencilBody = new THREE.Mesh(pencilBodyGeometry, pencilBodyMaterial);
        pencilBody.position.y = -2.85;
        pencilBody.castShadow = false;
        pencilLegGroup.add(pencilBody);
        
        // Pencil lead
        const pencilLeadGeometry = new THREE.ConeGeometry(0.08, 0.3, 16);
        const pencilLeadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const pencilLead = new THREE.Mesh(pencilLeadGeometry, pencilLeadMaterial);
        pencilLead.position.y = -3.15;
        pencilLead.rotation.x = Math.PI; // Point down
        pencilLead.castShadow = false;
        pencilLegGroup.add(pencilLead);
        
        // Variables for compass state
        let compassAngle = 30; // degrees
        let compassRadius = 2.0; // units
        let isDragging = false;
        let isDrawing = false;
        let drawingMode = false;
        let currentCircle = null;
        let drawStartTime = 0;
        let drawStartAngle = 0;
        let circles = [];
        
        // Update compass appearance based on angle
        function updateCompass() {
            // Convert angle to radians
            const radians = THREE.MathUtils.degToRad(compassAngle / 2); // Half the angle for each leg
            
            // Calculate compass radius
            compassRadius = 2 * Math.sin(THREE.MathUtils.degToRad(compassAngle) / 2) * 3;
            
            // Update the legs rotation - both legs tilt inward to meet at their tips
            needleLegGroup.rotation.z = radians;
            pencilLegGroup.rotation.z = -radians;
            
            // Position pencil leg horizontally
            pencilLegGroup.position.x = compassRadius;
            
            // Update UI display
            document.getElementById('angle').textContent = compassAngle.toFixed(1);
            document.getElementById('radius').textContent = compassRadius.toFixed(2);
        }
        
        // Create a complete circle at the current compass position
        function createCircle() {
            const circleGeometry = new THREE.BufferGeometry();
            const circleSegments = 64;
            const points = [];
            
            for (let i = 0; i <= circleSegments; i++) {
                const theta = (i / circleSegments) * Math.PI * 2;
                const x = compassGroup.position.x + compassRadius * Math.cos(theta);
                const z = compassGroup.position.z + compassRadius * Math.sin(theta);
                points.push(new THREE.Vector3(x, 0.01, z));
            }
            
            circleGeometry.setFromPoints(points);
            
            const circleMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0000ff,
                linewidth: 2
            });
            
            const circle = new THREE.Line(circleGeometry, circleMaterial);
            scene.add(circle);
            circles.push(circle);
            
            return circle;
        }
        
        // Create a dynamic circle for real-time drawing
        function createDynamicCircle() {
            const circleGeometry = new THREE.BufferGeometry();
            const circleMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0000ff,
                linewidth: 2
            });
            
            const circle = new THREE.Line(circleGeometry, circleMaterial);
            scene.add(circle);
            return circle;
        }
        
        // Update the dynamic circle as we draw - ensuring it appears under the pencil tip
        function updateDynamicCircle(startAngle, currentAngle) {
            if (!currentCircle) return;
            
            // Handle wrapping around the circle
            if (currentAngle < startAngle) {
                currentAngle += Math.PI * 2;
            }
            
            // Calculate how much of the circle to draw
            const angularDistance = currentAngle - startAngle;
            const circleSegments = 128;
            const numSegmentsToShow = Math.max(2, Math.ceil((angularDistance / (Math.PI * 2)) * circleSegments));
            
            const points = [];
            for (let i = 0; i <= numSegmentsToShow; i++) {
                const theta = startAngle + (i / circleSegments) * Math.PI * 2;
                if (theta > currentAngle && i > 0) break;
                
                const x = compassGroup.position.x + compassRadius * Math.cos(theta);
                const z = compassGroup.position.z + compassRadius * Math.sin(theta);
                points.push(new THREE.Vector3(x, 0.01, z));
            }
            
            // If we've completed more than 90% of the circle, complete it
            if (angularDistance >= Math.PI * 1.8) {
                for (let i = 0; i <= circleSegments; i++) {
                    const theta = (i / circleSegments) * Math.PI * 2;
                    const x = compassGroup.position.x + compassRadius * Math.cos(theta);
                    const z = compassGroup.position.z + compassRadius * Math.sin(theta);
                    points.push(new THREE.Vector3(x, 0.01, z));
                }
                isDrawing = false;
                circles.push(currentCircle);
                currentCircle = null;
            }
            
            if (currentCircle) {
                currentCircle.geometry.setFromPoints(points);
                currentCircle.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        // Reset the scene and compass
        function resetScene() {
            // Remove all drawn circles
            circles.forEach(circle => scene.remove(circle));
            circles = [];
            
            if (currentCircle) {
                scene.remove(currentCircle);
                currentCircle = null;
            }
            
            // Reset compass position
            compassGroup.position.set(0, 0, 0);
            
            // Reset compass angle
            compassAngle = 30;
            updateCompass();
            
            isDrawing = false;
        }
        
        // Initialize compass
        updateCompass();
        
        // Add event listeners for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Adjust compass angle with mouse wheel without affecting camera zoom
        window.addEventListener('wheel', function(event) {
            if (orbitControls.enabled) {
                // Normal orbit controls behavior
                return;
            }
            
            // Only prevent default if actively adjusting compass
            event.preventDefault();
            
            // Adjust compass angle (1 degree per wheel delta)
            compassAngle = Math.max(5, Math.min(120, compassAngle - event.deltaY * 0.1));
            updateCompass();
        }, { passive: false });
        
        // Mouse down handler
        window.addEventListener('mousedown', function(event) {
            // Right mouse button for positioning the compass
            if (event.button === 2 && !drawingMode) {
                orbitControls.enabled = false;
                isDragging = true;
                
                // Cast ray to find intersection with plane
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    compassGroup.position.x = point.x;
                    compassGroup.position.z = point.z;
                }
            }
            
            // Left mouse button in drawing mode
            if (event.button === 0 && drawingMode) {
                orbitControls.enabled = false;
                isDrawing = true;
                
                // Create a new dynamic circle
                if (currentCircle) scene.remove(currentCircle);
                currentCircle = createDynamicCircle();
                
                // Calculate starting angle
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    
                    // Calculate angle from compass center to start point
                    const dx = point.x - compassGroup.position.x;
                    const dz = point.z - compassGroup.position.z;
                    drawStartAngle = Math.atan2(dz, dx);
                    
                    // Rotate compass to starting position
                    compassGroup.rotation.y = drawStartAngle;
                }
                
                drawStartTime = Date.now();
            }
        });
        
        // Mouse move handler
        window.addEventListener('mousemove', function(event) {
            // Move compass if dragging
            if (isDragging) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    compassGroup.position.x = point.x;
                    compassGroup.position.z = point.z;
                }
            }
            
            // Draw circle if in drawing mode
            if (isDrawing) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    
                    // Calculate current angle
                    const dx = point.x - compassGroup.position.x;
                    const dz = point.z - compassGroup.position.z;
                    const currentAngle = Math.atan2(dz, dx);
                    
                    // Rotate compass to point toward mouse
                    compassGroup.rotation.y = currentAngle;
                    
                    // Update circle drawing - matching pencil tip position
                    updateDynamicCircle(drawStartAngle, currentAngle);
                }
            }
        });
        
        // Mouse up handler
        window.addEventListener('mouseup', function(event) {
            isDragging = false;
            
            if (isDrawing) {
                // If we've been drawing for a short time, complete the circle
                const drawTime = Date.now() - drawStartTime;
                
                if (drawTime < 500 || !currentCircle) {
                    // Short click - draw complete circle
                    if (currentCircle) scene.remove(currentCircle);
                    currentCircle = createCircle();
                    circles.push(currentCircle);
                } else {
                    // If the circle is still being drawn, complete it
                    const circleGeometry = new THREE.BufferGeometry();
                    const circleSegments = 64;
                    const points = [];
                    
                    for (let i = 0; i <= circleSegments; i++) {
                        const theta = (i / circleSegments) * Math.PI * 2;
                        const x = compassGroup.position.x + compassRadius * Math.cos(theta);
                        const z = compassGroup.position.z + compassRadius * Math.sin(theta);
                        points.push(new THREE.Vector3(x, 0.01, z));
                    }
                    
                    currentCircle.geometry.setFromPoints(points);
                    circles.push(currentCircle);
                }
                
                currentCircle = null;
                isDrawing = false;
            }
            
            orbitControls.enabled = true;
        });
        
        // Prevent context menu on right-click
        window.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });
        
        // Handle keyboard events for toggling wheel behavior
        window.addEventListener('keydown', function(event) {
            if (event.key === 'Shift') {
                orbitControls.enabled = false; // Disable orbit controls when holding Shift
            }
        });
        
        window.addEventListener('keyup', function(event) {
            if (event.key === 'Shift') {
                orbitControls.enabled = true; // Re-enable orbit controls when releasing Shift
            }
        });
        
        // Toggle mode button
        document.getElementById('toggle-mode').addEventListener('click', function() {
            drawingMode = !drawingMode;
            this.textContent = drawingMode ? "模式: 画圆" : "模式: 移动圆规";
        });
        
        // Reset button
        document.getElementById('reset').addEventListener('click', resetScene);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
