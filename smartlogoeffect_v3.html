<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SEN MART Logo Dynamic Effect</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden; /* 屏幕外裁剪（入场需要） */
      display: grid;
      place-items: center;
    }

    /* 不用 CSS transform 移动，避免移动端 SVG 合成裁剪问题 */
    .carrier { transform: none; }

    svg#logoSvg {
      width: min(70vw, 520px);
      height: auto;
      display: block;
      overflow: visible; /* SVG 自己不裁剪 */
    }

    .hint {
      position: absolute;
      left: 16px;
      bottom: 16px;
      font-size: 13px;
      color: #777;
      user-select: none;
    }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <div class="carrier" id="carrier">
      <svg id="logoSvg" overflow="visible" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 432 215" width="432" height="215" aria-label="logo">
        <g id="motionRoot">
          <g id="parts" fill="#000" stroke="none">
            <path d="m 268 34 l 82 142 64 1 -82 -143 z"/>
            <path d="m 28 34 l 81 142 65 0 -83 -142 z"/>
            <path d="m 208 34 l 0 36 61 106 65 0 -80 -139 z"/>
            <path d="m 107 34 l 17 30 36 0 30 52 0 -82 z"/>
            <path d="m 11 98 l 0 78 81 0 -15 -26 -35 0 z"/>
            <path d="m 207 99 l 0 77 45 0 z"/>
            <path d="m 11 190 l 0 16 4 1 95 -1 -10 -16 z"/>
            <path d="m 190 21 l 0 -13 -99 0 8 13 z"/>
            <path d="m 278 190 l 10 17 63 0 -9 -17 z"/>
            <path d="m 358 190 l 9 16 64 0 -9 -16 z"/>
            <path d="m 207 190 l 1 17 61 0 -9 -17 z"/>
            <path d="m 117 190 l 9 15 64 0 -8 -15 z"/>
            <path d="m 11 6 l 9 15 64 0 -9 -15 z"/>
            <path d="m 252 7 l 8 14 64 0 -8 -14 z"/>
            <path d="m 207 8 l 1 13 36 0 -8 -14 -28 0 z"/>
          </g>
        </g>
      </svg>
    </div>
  </div>

  <script>
    (() => {
      const stage = document.getElementById('stage');
      const svg = document.getElementById('logoSvg');
      const motionRoot = document.getElementById('motionRoot');
      const partsGroup = document.getElementById('parts');
      const paths = Array.from(partsGroup.querySelectorAll('path'));

      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (reduceMotion) return;

      // ---------- 可调参数 ----------
      const CONFIG = {
        // 注意：tAccel 在这个版本里不再表示“加速时长”。
        // 它作为“速度/刹车手感”的基准时间参数保留下来（保持你原来的数值即可）。
        // 想整体更慢/更快：调大/调小 tAccel。
        tAccel: 1.15,
        brakeRatio: 6.5,
        tSettle: 1.20,

        maxGap: 78,
        compressBoost: 1.35,

        tailGamma: 0.88,

        strainOmega: 16.0,
        strainZeta: 0.30,

        partOmegaBase: 22.0,
        partZetaBase: 0.55,

        collisionMinDistFactor: 0.58,
        restitution: 0.72,
        collisionIters: 3,

        joltDy: 6.5,
        joltRotDeg: 7.0,

        brakeLock: 0.92,
        brakeVelDamp: 0.75,

        // 防手机裁剪的安全边界约束
        safePadPx: 10,
        safeFitOmega: 26.0,
        safeFitZeta: 0.80,
        safeFitStartProgress: 0.62
      };

      // 形变驱动系数：提高 kV，让“匀速高速”阶段也能保持最大松散
      const K_V = 1.20;
      const K_A = 1.60;

      const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

      // 二阶系统：x'' = ω²(target-x) - 2ζω x'
      function stepSecondOrder(state, target, dt, omega, zeta) {
        const x = state.x;
        const v = state.v;
        const a = (omega * omega) * (target - x) - (2 * zeta * omega) * v;
        state.v = v + a * dt;
        state.x = x + state.v * dt;
      }

      function getViewBoxCenter() {
        const vb = svg.viewBox.baseVal;
        return {
          cx: vb.x + vb.width / 2,
          cy: vb.y + vb.height / 2,
          w: vb.width,
          h: vb.height
        };
      }

      function buildPartsMeta() {
        const { cx: vcx, cy: vcy, h: vh } = getViewBoxCenter();

        const metas = paths.map((el, idx) => {
          const bb = el.getBBox();
          const pcx = bb.x + bb.width / 2;
          const pcy = bb.y + bb.height / 2;

          const ny = (pcy - vcy) / (vh / 2);

          const rnd1 = (Math.random() * 2 - 1);
          const rnd2 = (Math.random() * 2 - 1);

          const mass = Math.max(1, bb.width * bb.height);

          const partOmega = CONFIG.partOmegaBase * (0.90 + 0.25 * Math.abs(rnd1));
          const partZeta  = CONFIG.partZetaBase  * (0.90 + 0.20 * Math.abs(rnd2));

          return {
            el, idx, bb,
            pcx, pcy,
            ny,
            rnd1, rnd2,
            mass,
            partOmega,
            partZeta,
            ox: { x: 0, v: 0 },
            u: 0,    // 0=最左，1=最右
            tail: 0  // 1=尾部(左)，0=头部(右)
          };
        });

        const minX = Math.min(...metas.map(m => m.pcx));
        const maxX = Math.max(...metas.map(m => m.pcx));
        const rangeX = Math.max(1e-6, maxX - minX);

        for (const m of metas) {
          m.u = (m.pcx - minX) / rangeX;
          m.tail = 1 - m.u;
        }

        const order = metas.slice().sort((a, b) => a.pcx - b.pcx);
        for (let i = 0; i < order.length - 1; i++) {
          const a = order[i];
          const b = order[i + 1];
          a.next = b;
          a.d0ToNext = (b.pcx - a.pcx);
        }
        order[order.length - 1].next = null;
        order[order.length - 1].d0ToNext = 0;

        return { metas, order };
      }

      // ✅ 新运动学：匀速入场（a=0），到刹车点后常减速刹停。
      // 速度选择：匹配“旧模型中刹车开始前的最高速度”，保证你感知到的是“原先最后那种中高速度”的匀速入场。
      function makeKinematics(distancePx) {
        const tBase = CONFIG.tAccel;
        const r = CONFIG.brakeRatio;

        const tBrake = tBase / r;

        // 旧模型的刹车前最高速度 v1 = 2*distance / (tBase*(1+1/r))
        const vCruise = (2 * distancePx) / (tBase * (1 + 1 / r));

        // distance = vCruise*tCruise + 0.5*vCruise*tBrake
        const tCruise = Math.max(0, (distancePx / vCruise) - 0.5 * tBrake);

        const aBrake = -vCruise / tBrake;
        const xCruise = vCruise * tCruise;
        const tMove = tCruise + tBrake;

        function sample(t) {
          if (t <= 0) return { x: 0, v: vCruise, a: 0 };
          if (t < tCruise) {
            return { x: vCruise * t, v: vCruise, a: 0 };
          }
          if (t < tMove) {
            const tb = t - tCruise;
            return {
              x: xCruise + vCruise * tb + 0.5 * aBrake * tb * tb,
              v: vCruise + aBrake * tb,
              a: aBrake
            };
          }
          return { x: distancePx, v: 0, a: 0 };
        }

        return { tMove, tCruise, tBrake, a1: 0, a2: aBrake, v1: vCruise, sample };
      }

      let anim = null;

      function play() {
        if (anim && anim.rafId) cancelAnimationFrame(anim.rafId);

        // 清空 transform
        motionRoot.removeAttribute('transform');
        for (const p of paths) p.removeAttribute('transform');

        // 布局测量
        const stageRect = stage.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();
        const vb = svg.viewBox.baseVal;

        const margin = 40;
        const scaleX = svgRect.width / (vb.width || 432);

        // 入场起点（px）：保证最大展开状态也完全在左侧屏幕外
        const maxOverhangLeftPx = CONFIG.maxGap * 1.6 * scaleX;
        const startXpx = -((stageRect.width + svgRect.width) / 2 + margin + maxOverhangLeftPx);
        const distancePx = -startXpx;

        const kine = makeKinematics(distancePx);
        const { metas, order } = buildPartsMeta();

        const strain = { x: 0, v: 0 };
        const safe = { x: 0, v: 0 };

        function computeBrakeAmount(a) {
          const aMax = Math.max(1e-6, Math.max(Math.abs(kine.a1), Math.abs(kine.a2)));
          return clamp((-a) / aMax, 0, 1);
        }

        function effInvMass(m, brakeAmt) {
          const inv = 1 / m.mass;
          const lock = brakeAmt * CONFIG.brakeLock * Math.pow(m.u, 4);
          return inv * (1 - lock);
        }

        // ✅ 初始化为“已在高速匀速行驶”的形态，避免入场时间隙慢慢变大造成“加速错觉”
        const initTargetStrain = clamp(K_V * 1 + K_A * 0, -1.2, 1.2); // vNorm=1, aNorm=0
        strain.x = initTargetStrain;
        strain.v = 0;

        for (const m of metas) {
          const tailPow = Math.pow(m.tail, CONFIG.tailGamma);
          const desired = -tailPow * strain.x * CONFIG.maxGap; // 匀速高速 => 尾部(左)向左拉开
          m.ox.x = desired;
          m.ox.v = 0;

          const dx = m.ox.x;
          const dy = (m.ny * dx * 0.06);
          const rot = 0;
          m.el.setAttribute(
            'transform',
            `translate(${dx.toFixed(3)} ${dy.toFixed(3)}) rotate(${rot} ${m.pcx.toFixed(3)} ${m.pcy.toFixed(3)})`
          );
        }

        // ✅ 先把整体放到左侧屏幕外（避免首帧闪现居中）
        motionRoot.setAttribute('transform', `translate(${(startXpx / scaleX).toFixed(3)} 0)`);

        const tTotal = kine.tMove + CONFIG.tSettle;

        anim = {
          rafId: 0,
          t0: performance.now(),
          last: performance.now(),
          startXpx,
          distancePx,
          kine,
          metas,
          order,
          strain,
          safe,
          layout: {
            stageW: stageRect.width,
            svgW: svgRect.width,
            vbX: vb.x || 0,
            vbW: vb.width || 432,
            scaleX,
            padPx: Math.max(CONFIG.safePadPx, stageRect.width * 0.02)
          }
        };

        function frame(now) {
          const dt = clamp((now - anim.last) / 1000, 0, 0.033);
          anim.last = now;

          const t = (now - anim.t0) / 1000;

          // 1) 匀速入场/刹车位移（px）
          const s = anim.kine.sample(t);
          const moveXpx = anim.startXpx + s.x;

          // 2) strain 目标：速度拉开 + 减速度压缩
          const vNorm = (anim.kine.v1 > 1e-6) ? (s.v / anim.kine.v1) : 0;
          const aMax = Math.max(1e-6, Math.max(Math.abs(anim.kine.a1), Math.abs(anim.kine.a2)));
          const aNorm = (aMax > 1e-6) ? (s.a / aMax) : 0;

          let targetStrain = K_V * vNorm + K_A * aNorm;
          targetStrain = clamp(targetStrain, -1.2, 1.2);

          stepSecondOrder(anim.strain, targetStrain, dt, CONFIG.strainOmega, CONFIG.strainZeta);

          const brakeAmt = computeBrakeAmount(s.a);
          const strainNow = anim.strain.x;
          const gap = CONFIG.maxGap;

          // 3) 模块目标偏移（右端锚点）
          for (const m of anim.metas) {
            const tailPow = Math.pow(m.tail, CONFIG.tailGamma);

            let desired = -tailPow * strainNow * gap;
            if (strainNow < 0) desired *= CONFIG.compressBoost;

            stepSecondOrder(m.ox, desired, dt, m.partOmega, m.partZeta);

            // 刹车时右端更快停住
            if (brakeAmt > 0) {
              const damp = brakeAmt * CONFIG.brakeVelDamp * Math.pow(m.u, 2);
              m.ox.v *= (1 - clamp(damp, 0, 0.95));
            }
          }

          // 4) 碰撞
          for (let iter = 0; iter < CONFIG.collisionIters; iter++) {
            for (let i = 0; i < anim.order.length - 1; i++) {
              const a = anim.order[i];
              const b = anim.order[i + 1];

              const d0 = a.d0ToNext;
              if (d0 <= 0) continue;

              const minDist = Math.max(6, d0 * CONFIG.collisionMinDistFactor);

              const pa = a.pcx + a.ox.x;
              const pb = b.pcx + b.ox.x;
              const dist = pb - pa;

              if (dist < minDist) {
                const overlap = (minDist - dist);

                const invA = effInvMass(a, brakeAmt);
                const invB = effInvMass(b, brakeAmt);
                const sumInv = invA + invB;
                if (sumInv < 1e-9) continue;

                a.ox.x -= overlap * (invA / sumInv);
                b.ox.x += overlap * (invB / sumInv);

                const ua = a.ox.v;
                const ub = b.ox.v;
                const rel = ub - ua;

                if (rel < 0) {
                  const e = CONFIG.restitution;
                  const j = (-(1 + e) * rel) / sumInv;
                  a.ox.v -= j * invA;
                  b.ox.v += j * invB;
                }
              }
            }
          }

          // 5) 写回 transform（局部）
          const jolt = brakeAmt;
          for (const m of anim.metas) {
            const dx = m.ox.x;

            const tailAmp = 0.35 + 0.65 * m.tail;

            const dy = (m.rnd1 * CONFIG.joltDy) * jolt * tailAmp + (m.ny * dx * 0.06);
            const rot = (m.rnd2 * CONFIG.joltRotDeg) * jolt * tailAmp;

            m.el.setAttribute(
              'transform',
              `translate(${dx.toFixed(3)} ${dy.toFixed(3)}) rotate(${rot.toFixed(3)} ${m.pcx.toFixed(3)} ${m.pcy.toFixed(3)})`
            );
          }

          // 6) 手机端安全边界（防刹车回弹时左侧被裁）
          const L = anim.layout;

          let minX = Infinity, maxX = -Infinity;
          for (const m of anim.metas) {
            const x0 = m.bb.x + m.ox.x;
            const x1 = m.bb.x + m.bb.width + m.ox.x;
            if (x0 < minX) minX = x0;
            if (x1 > maxX) maxX = x1;
          }

          const padVb = (L.padPx / L.scaleX);
          minX -= padVb;
          maxX += padVb;

          const minLocalPx = (minX - L.vbX) * L.scaleX;
          const maxLocalPx = (maxX - L.vbX) * L.scaleX;

          const minStageNoSafe = (-L.svgW / 2) + minLocalPx + moveXpx;
          const maxStageNoSafe = (-L.svgW / 2) + maxLocalPx + moveXpx;

          const leftLimit = (-L.stageW / 2) + L.padPx;
          const rightLimit = ( L.stageW / 2) - L.padPx;

          let targetSafePx = 0;
          if (minStageNoSafe < leftLimit) targetSafePx += (leftLimit - minStageNoSafe);
          if (maxStageNoSafe > rightLimit) targetSafePx += (rightLimit - maxStageNoSafe);

          const progress = (anim.distancePx > 1e-6) ? (s.x / anim.distancePx) : 1;
          const blend = clamp(
            (progress - CONFIG.safeFitStartProgress) / (1 - CONFIG.safeFitStartProgress),
            0, 1
          );
          targetSafePx *= blend;

          stepSecondOrder(anim.safe, targetSafePx, dt, CONFIG.safeFitOmega, CONFIG.safeFitZeta);

          // 7) 整体位移写到 motionRoot（SVG transform）
          const globalXpx = moveXpx + anim.safe.x;
          const globalXvb = globalXpx / L.scaleX;
          motionRoot.setAttribute('transform', `translate(${globalXvb.toFixed(3)} 0)`);

          // 8) 结束归位
          if (t < tTotal) {
            anim.rafId = requestAnimationFrame(frame);
          } else {
            motionRoot.removeAttribute('transform');
            for (const p of paths) p.removeAttribute('transform');
          }
        }

        anim.rafId = requestAnimationFrame(frame);
      }

      requestAnimationFrame(() => play());
      stage.addEventListener('click', () => play());
      window.addEventListener('resize', () => play());
    })();
  </script>
</body>
</html>
