<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ä¸‰è§’å‡½æ•°åŠ¨æ€æ¼”ç¤º</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      .container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      #main-container {
        flex: 1;
        min-width: 600px;
      }
      #info-panel {
        width: 250px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #ddd;
        font-size: 14px;
      }
      #graph-container {
        width: 100%;
        margin-top: 20px;
      }
      #graph-canvas {
        width: 100%;
        height: 200px;
        border: 1px solid #ddd;
        background-color: #f9f9f9;
      }
      canvas {
        border: 1px solid #ddd;
        background-color: #f9f9f9;
      }
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th,
      td {
        padding: 5px 10px;
        text-align: left;
      }
      th {
        font-weight: bold;
      }
      .instruction {
        margin: 10px 0;
        color: #555;
      }
      h1 {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>ä¸‰è§’å‡½æ•°åŠ¨æ€æ¼”ç¤º</h1>
    <p class="instruction">ç‚¹å‡»å¹¶æ‹–åŠ¨çº¢è‰²å°„çº¿æ¥æ”¹å˜è§’åº¦</p>

    <div class="container">
      <div id="main-container">
        <canvas id="trig-canvas" width="600" height="600"></canvas>
      </div>

      <div id="info-panel">
        <table>
          <tr>
            <th style="color: red">OA (åŠå¾„):</th>
            <td id="oa-value" style="color: red">1</td>
          </tr>
          <tr>
            <th style="color: gold">OB:</th>
            <td id="ob-value" style="color: gold">1</td>
          </tr>
          <tr>
            <th style="color: blue">AB:</th>
            <td id="ab-value" style="color: blue">0</td>
          </tr>
          <tr>
            <th>è§’åº¦ğœƒ:</th>
            <td id="angle-value">0Â°</td>
          </tr>
          <tr>
            <th>
              sinğœƒ =
              <div style="display: inline-block; text-align: center">
                <span style="color: blue">AB</span><br />
                <span
                  style="border-top: 1px solid black; display: block"
                ></span>
                <span style="color: red">OA</span>
              </div>
              :
            </th>
            <td id="sin-value">0</td>
          </tr>
          <tr>
            <th>
              cosğœƒ =
              <div style="display: inline-block; text-align: center">
                <span style="color: gold">OB</span><br />
                <span
                  style="border-top: 1px solid black; display: block"
                ></span>
                <span style="color: red">OA</span>
              </div>
              :
            </th>
            <td id="cos-value">1</td>
          </tr>
          <tr>
            <th>
              tanğœƒ =
              <div style="display: inline-block; text-align: center">
                <span style="color: blue">AB</span><br />
                <span
                  style="border-top: 1px solid black; display: block"
                ></span>
                <span style="color: gold">OB</span>
              </div>
              :
            </th>
            <td id="tan-value">0</td>
          </tr>
        </table>
      </div>
    </div>

    <div id="graph-container">
      <canvas id="graph-canvas" width="900" height="200"></canvas>
    </div>

    <script>
      // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
      const canvas = document.getElementById("trig-canvas");
      const ctx = canvas.getContext("2d");

      // è·å–å‡½æ•°å›¾åƒç”»å¸ƒå’Œä¸Šä¸‹æ–‡
      const graphCanvas = document.getElementById("graph-canvas");
      const graphCtx = graphCanvas.getContext("2d");

      // è°ƒæ•´canvaså…ƒç´ å®é™…å°ºå¯¸ä»¥åŒ¹é…å…¶CSSå°ºå¯¸
      function resizeCanvas() {
        // è°ƒæ•´å›¾å½¢ç”»å¸ƒå°ºå¯¸
        const graphContainerWidth =
          document.getElementById("graph-container").offsetWidth;
        graphCanvas.width = graphContainerWidth;
        graphCanvas.height = 200;
      }

      // ç«‹å³è°ƒæ•´å¹¶åœ¨çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°è°ƒæ•´
      resizeCanvas();
      window.addEventListener("resize", function () {
        resizeCanvas();
        drawScene();
        drawFunctionGraphs();
      });

      // è®¾ç½®ç”»å¸ƒå’Œåæ ‡ç³»çš„å‚æ•°
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = 100; // åæ ‡ç³»çš„ç¼©æ”¾æ¯”ä¾‹

      // è§’åº¦å’Œä¸‰è§’å‡½æ•°å€¼
      let angle = 0; // åˆå§‹è§’åº¦ä¸º0
      const radius = 2; // å›ºå®šåŠå¾„OA
      let isDragging = false;

      // åˆå§‹åŒ–å‡½æ•°
      function init() {
        // åˆå§‹ç»˜åˆ¶
        drawScene();
        drawFunctionGraphs();

        // æ·»åŠ é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", () => (isDragging = false));
        canvas.addEventListener("mouseleave", () => (isDragging = false));

        // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        canvas.addEventListener("touchstart", handleTouchStart);
        canvas.addEventListener("touchmove", handleTouchMove);
        canvas.addEventListener("touchend", () => (isDragging = false));
      }

      // ç»˜åˆ¶æ•´ä¸ªåœºæ™¯
      function drawScene() {
        // æ¸…é™¤ç”»å¸ƒ
        ctx.clearRect(0, 0, width, height);

        // ç»˜åˆ¶åæ ‡ç³»
        drawCoordinateSystem();

        // è®¡ç®—ç‚¹Açš„ä½ç½®
        const pointA = {
          x: centerX + radius * scale * Math.cos(angle),
          y: centerY - radius * scale * Math.sin(angle),
        };

        // è®¡ç®—ç‚¹Bçš„ä½ç½®
        const pointB = {
          x: pointA.x,
          y: centerY,
        };

        // ç»˜åˆ¶OBçº¿æ®µï¼ˆé»„è‰²ï¼‰
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(pointB.x, pointB.y);
        ctx.strokeStyle = "gold";
        ctx.lineWidth = 2;
        ctx.stroke();

        // ç»˜åˆ¶OAçº¿æ®µï¼ˆçº¢è‰²ï¼‰
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(pointA.x, pointA.y);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();

        // ç»˜åˆ¶ABçº¿æ®µï¼ˆè“è‰²è™šçº¿ï¼‰
        ctx.beginPath();
        ctx.moveTo(pointA.x, pointA.y);
        ctx.lineTo(pointB.x, pointB.y);
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 3]);
        ctx.stroke();
        ctx.setLineDash([]);

        // ç»˜åˆ¶ç‚¹O
        drawPoint(centerX, centerY, "black", "O");

        // ç»˜åˆ¶ç‚¹A
        drawPoint(pointA.x, pointA.y, "red", "A");

        // ç»˜åˆ¶ç‚¹B
        drawPoint(pointB.x, pointB.y, "blue", "B");

        // ç»˜åˆ¶è§’åº¦å¼§
        drawAngleArc();

        // æ›´æ–°æ•°å€¼æ˜¾ç¤º
        updateValues();
      }

      // ç»˜åˆ¶åæ ‡ç³»
      function drawCoordinateSystem() {
        // ç»˜åˆ¶æ·¡è‰²åæ ‡æ ¼
        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 0.5;

        // ç»˜åˆ¶æ°´å¹³å’Œå‚ç›´ç½‘æ ¼çº¿
        for (let i = -10; i <= 10; i++) {
          // æ°´å¹³çº¿
          ctx.beginPath();
          ctx.moveTo(0, centerY + i * scale);
          ctx.lineTo(width, centerY + i * scale);
          ctx.stroke();

          // å‚ç›´çº¿
          ctx.beginPath();
          ctx.moveTo(centerX + i * scale, 0);
          ctx.lineTo(centerX + i * scale, height);
          ctx.stroke();
        }

        // ç»˜åˆ¶xè½´å’Œyè½´
        ctx.strokeStyle = "#999";
        ctx.lineWidth = 1;

        // xè½´
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(width, centerY);
        ctx.stroke();

        // yè½´
        ctx.beginPath();
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, height);
        ctx.stroke();

        // ç»˜åˆ¶åˆ»åº¦å’Œæ ‡ç­¾
        ctx.fillStyle = "#666";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "12px Arial";

        // xè½´åˆ»åº¦
        for (let i = -5; i <= 5; i++) {
          if (i === 0) continue;

          const x = centerX + i * scale;
          ctx.beginPath();
          ctx.moveTo(x, centerY - 5);
          ctx.lineTo(x, centerY + 5);
          ctx.stroke();

          ctx.fillText(i.toString(), x, centerY + 15);
        }

        // yè½´åˆ»åº¦
        for (let i = -5; i <= 5; i++) {
          if (i === 0) continue;

          const y = centerY - i * scale;
          ctx.beginPath();
          ctx.moveTo(centerX - 5, y);
          ctx.lineTo(centerX + 5, y);
          ctx.stroke();

          ctx.fillText(i.toString(), centerX - 15, y);
        }

        // åŸç‚¹æ ‡è®°
        ctx.fillText("0", centerX - 15, centerY + 15);
      }

      // ç»˜åˆ¶ç‚¹
      function drawPoint(x, y, color, label) {
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        // æ·»åŠ æ ‡ç­¾
        ctx.fillStyle = "black";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // æ ¹æ®ç‚¹çš„ä½ç½®è°ƒæ•´æ ‡ç­¾ä½ç½®
        let labelX = x;
        let labelY = y;

        if (label === "O") {
          labelX -= 10;
          labelY += 10;
        } else if (label === "A") {
          if (angle < Math.PI / 2) {
            labelX += 10;
            labelY -= 10;
          } else if (angle < Math.PI) {
            labelX -= 10;
            labelY -= 10;
          } else if (angle < (3 * Math.PI) / 2) {
            labelX -= 10;
            labelY += 10;
          } else {
            labelX += 10;
            labelY += 10;
          }
        } else if (label === "B") {
          labelY += 15;
        }

        ctx.fillText(label, labelX, labelY);
      }

      // ç»˜åˆ¶è§’åº¦å¼§
      function drawAngleArc() {
        const arcRadius = 30;
        ctx.beginPath();
        // ä»Xè½´æ­£æ–¹å‘é€†æ—¶é’ˆç»˜åˆ¶åˆ°å½“å‰è§’åº¦
        ctx.arc(centerX, centerY, arcRadius, 0, 2*Math.PI-angle, true);
        ctx.strokeStyle = "rgba(128, 0, 128, 0.6)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // åœ¨å¼§çš„ä¸­é—´ç»˜åˆ¶è§’åº¦ç¬¦å·
        const midAngle = angle / 2;
        const labelX = centerX + (arcRadius + 10) * Math.cos(midAngle);
        const labelY = centerY - (arcRadius + 10) * Math.sin(midAngle);

        ctx.fillStyle = "purple";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Î¸", labelX, labelY);
      }

      function updateValues() {
        // è®¡ç®—ä¸‰è§’å‡½æ•°å€¼
        const cosValue = Math.cos(angle);
        const sinValue = Math.sin(angle);
        let tanDisplay;
        if (Math.abs(cosValue) < 0.0001) {
          tanDisplay = "ä¸å­˜åœ¨";
        } else {
          tanDisplay = (sinValue / cosValue).toFixed(4);
        }

        // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬ï¼ˆåªæ›´æ–°ä¸€æ¬¡ï¼‰
        document.getElementById("tan-value").textContent = tanDisplay;

        // è®¡ç®—é•¿åº¦
        const oaLength = radius;
        const obLength = radius * cosValue;
        const abLength = radius * sinValue;

        // æ›´æ–°å…¶ä»–æ˜¾ç¤º
        document.getElementById("oa-value").textContent = oaLength.toFixed(2);
        document.getElementById("ob-value").textContent = obLength.toFixed(2);
        document.getElementById("ab-value").textContent = abLength.toFixed(2);
        document.getElementById("angle-value").textContent = `${(
          (angle * 180) /
          Math.PI
        ).toFixed(1)}Â°`;
        document.getElementById("sin-value").textContent = sinValue.toFixed(4);
        document.getElementById("cos-value").textContent = cosValue.toFixed(4);
        // Remove the following erroneous line:
        // document.getElementById("tan-value").textContent = tanValue.toFixed(4);
      }

      // ç»˜åˆ¶å‡½æ•°å›¾åƒ
      function drawFunctionGraphs() {
        const graphWidth = graphCanvas.width;
        const graphHeight = graphCanvas.height;

        // æ¸…é™¤ç”»å¸ƒ
        graphCtx.clearRect(0, 0, graphWidth, graphHeight);

        // è®¾ç½®åæ ‡ç³»
        const graphMargin = Math.max(40, graphWidth * 0.05);
        const graphCenterY = graphHeight / 2;
        const graphScaleY = graphHeight / 4; // å‚ç›´ç¼©æ”¾

        // ç»˜åˆ¶xè½´ï¼ˆæ°´å¹³ä¸­çº¿ï¼‰
        graphCtx.beginPath();
        graphCtx.moveTo(graphMargin, graphCenterY);
        graphCtx.lineTo(graphWidth - graphMargin, graphCenterY);
        graphCtx.strokeStyle = "#999";
        graphCtx.lineWidth = 1;
        graphCtx.stroke();

        // ç»˜åˆ¶yè½´
        graphCtx.beginPath();
        graphCtx.moveTo(graphMargin, 10);
        graphCtx.lineTo(graphMargin, graphHeight - 10);
        graphCtx.stroke();

        // ç»˜åˆ¶æ°´å¹³è¾…åŠ©çº¿
        for (let i = -1; i <= 1; i += 0.5) {
          if (i === 0) continue; // è·³è¿‡xè½´

          const y = graphCenterY - i * graphScaleY;

          graphCtx.beginPath();
          graphCtx.moveTo(graphMargin, y);
          graphCtx.lineTo(graphWidth - graphMargin, y);
          graphCtx.strokeStyle = "#ddd";
          graphCtx.lineWidth = 0.5;
          graphCtx.stroke();

          // æ·»åŠ åˆ»åº¦æ ‡ç­¾
          graphCtx.fillStyle = "#666";
          graphCtx.font = "12px Arial";
          graphCtx.textAlign = "right";
          graphCtx.textBaseline = "middle";
          graphCtx.fillText(i.toString(), graphMargin - 5, y);
        }

        // ç»˜åˆ¶Ï€/2, Ï€, 3Ï€/2, 2Ï€åˆ»åº¦çº¿
        const piPositions = [
          { x: 0.25, label: "Ï€/2" },
          { x: 0.5, label: "Ï€" },
          { x: 0.75, label: "3Ï€/2" },
          { x: 1, label: "2Ï€" },
        ];

        piPositions.forEach((pos) => {
          const xPos = graphMargin + pos.x * (graphWidth - 2 * graphMargin);

          // åˆ»åº¦çº¿
          graphCtx.beginPath();
          graphCtx.moveTo(xPos, graphCenterY - 5);
          graphCtx.lineTo(xPos, graphCenterY + 5);
          graphCtx.strokeStyle = "#999";
          graphCtx.lineWidth = 1;
          graphCtx.stroke();

          // åˆ»åº¦æ ‡ç­¾
          graphCtx.fillStyle = "#666";
          graphCtx.font = "12px Arial";
          graphCtx.textAlign = "center";
          graphCtx.textBaseline = "top";
          graphCtx.fillText(pos.label, xPos, graphCenterY + 8);
        });

        // æ·»åŠ 0æ ‡ç­¾
        graphCtx.textAlign = "center";
        graphCtx.textBaseline = "top";
        graphCtx.fillText("0", graphMargin, graphCenterY + 8);

        // æ·»åŠ yè½´æ ‡ç­¾
        graphCtx.save();
        graphCtx.translate(graphMargin - 25, graphHeight / 2);
        graphCtx.rotate(-Math.PI / 2);
        graphCtx.textAlign = "center";
        graphCtx.fillText("å€¼", 0, 0);
        graphCtx.restore();

        // ç»˜åˆ¶å‡½æ•°æ›²çº¿
        const drawCurve = (func, color) => {
          graphCtx.beginPath();

          for (let x = 0; x <= 2 * Math.PI; x += 0.01) {
            const graphX =
              graphMargin +
              (x / (2 * Math.PI)) * (graphWidth - 2 * graphMargin);
            const graphY = graphCenterY - func(x) * graphScaleY;

            if (x === 0) {
              graphCtx.moveTo(graphX, graphY);
            } else {
              graphCtx.lineTo(graphX, graphY);
            }
          }

          graphCtx.strokeStyle = color;
          graphCtx.lineWidth = 2;
          graphCtx.stroke();
        };

        // ç»˜åˆ¶sinæ›²çº¿
        drawCurve(Math.sin, "blue");

        // ç»˜åˆ¶cosæ›²çº¿
        drawCurve(Math.cos, "gold");

        // ç»˜åˆ¶tanæ›²çº¿ï¼Œåˆ†æ®µç»˜åˆ¶é¿å…åœ¨90Â°å’Œ270Â°é™„è¿‘ç›¸è¿
        const tanSegments = [];
        let currentSegment = [];
        for (let x = 0; x <= 2 * Math.PI; x += 0.01) {
          // å½“æ¥è¿‘ tan çš„æ¸è¿‘çº¿æ—¶ç»“æŸå½“å‰æ®µ
          if (
            Math.abs(x - Math.PI / 2) < 0.03 ||
            Math.abs(x - (3 * Math.PI) / 2) < 0.03
          ) {
            if (currentSegment.length > 0) {
              tanSegments.push(currentSegment);
              currentSegment = [];
            }
            continue;
          }
          const tanValue = Math.tan(x);
          // å¦‚æœä¸å‰ä¸€ä¸ªç‚¹å·®å€¼è¿‡å¤§ï¼Œåˆ™è®¤ä¸ºè·¨è¶Šäº†æ¸è¿‘çº¿ï¼Œç»“æŸå½“å‰æ®µ
          if (currentSegment.length > 0) {
            const prevTan = currentSegment[currentSegment.length - 1].tan;
            if (Math.abs(tanValue - prevTan) > 1) {
              tanSegments.push(currentSegment);
              currentSegment = [];
            }
          }
          currentSegment.push({ x: x, tan: tanValue });
        }
        if (currentSegment.length > 0) tanSegments.push(currentSegment);

        // ç»˜åˆ¶æ‰€æœ‰ tan æ›²çº¿åˆ†æ®µ
        graphCtx.strokeStyle = "green";
        graphCtx.lineWidth = 2;
        tanSegments.forEach((segment) => {
          graphCtx.beginPath();
          segment.forEach((point, index) => {
            const graphX =
              graphMargin +
              (point.x / (2 * Math.PI)) * (graphWidth - 2 * graphMargin);
            const graphY = graphCenterY - point.tan * graphScaleY;
            if (index === 0) {
              graphCtx.moveTo(graphX, graphY);
            } else {
              graphCtx.lineTo(graphX, graphY);
            }
          });
          graphCtx.stroke();
        });

        // æ·»åŠ å›¾ä¾‹
        const legendItems = [
          { label: "sin", color: "blue" },
          { label: "cos", color: "gold" },
          { label: "tan", color: "green" },
        ];

        const legendX = graphWidth - 100;
        let legendY = 20;
        legendItems.forEach((item) => {
          // ç»˜åˆ¶å½©è‰²çº¿æ¡
          graphCtx.beginPath();
          graphCtx.moveTo(legendX, legendY);
          graphCtx.lineTo(legendX + 20, legendY);
          graphCtx.strokeStyle = item.color;
          graphCtx.lineWidth = 2;
          graphCtx.stroke();

          // ç»˜åˆ¶æ ‡ç­¾
          graphCtx.fillStyle = "#333";
          graphCtx.font = "14px Arial";
          graphCtx.textAlign = "left";
          graphCtx.textBaseline = "middle";
          graphCtx.fillText(item.label, legendX + 25, legendY);

          legendY += 25;
        });

        // ç»˜åˆ¶å½“å‰è§’åº¦çš„ç‚¹
        const currentX =
          graphMargin +
          (angle / (2 * Math.PI)) * (graphWidth - 2 * graphMargin);

        // sinç‚¹
        const sinY = graphCenterY - Math.sin(angle) * graphScaleY;
        graphCtx.beginPath();
        graphCtx.arc(currentX, sinY, 5, 0, Math.PI * 2);
        graphCtx.fillStyle = "blue";
        graphCtx.fill();
        graphCtx.strokeStyle = "white";
        graphCtx.lineWidth = 1;
        graphCtx.stroke();

        // cosç‚¹
        const cosY = graphCenterY - Math.cos(angle) * graphScaleY;
        graphCtx.beginPath();
        graphCtx.arc(currentX, cosY, 5, 0, Math.PI * 2);
        graphCtx.fillStyle = "gold";
        graphCtx.fill();
        graphCtx.strokeStyle = "white";
        graphCtx.lineWidth = 1;
        graphCtx.stroke();

        // tanç‚¹ï¼ˆå¦‚æœåœ¨å¯è§èŒƒå›´å†…ï¼‰
        if (Math.abs(Math.tan(angle)) <= 3) {
          const tanY = graphCenterY - Math.tan(angle) * graphScaleY;
          graphCtx.beginPath();
          graphCtx.arc(currentX, tanY, 5, 0, Math.PI * 2);
          graphCtx.fillStyle = "green";
          graphCtx.fill();
          graphCtx.strokeStyle = "white";
          graphCtx.lineWidth = 1;
          graphCtx.stroke();
        }
      }

      // å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
      function handleMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨Oç‚¹é™„è¿‘
        const distToO = Math.sqrt(
          Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2)
        );

        // å¦‚æœé¼ æ ‡åœ¨ç”»å¸ƒä¸Šï¼Œå°±å¼€å§‹æ‹–åŠ¨
        isDragging = true;

        // ç«‹å³æ›´æ–°è§’åº¦
        updateAngle(mouseX, mouseY);
      }

      // å¤„ç†é¼ æ ‡ç§»åŠ¨äº‹ä»¶
      function handleMouseMove(e) {
        if (!isDragging) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        updateAngle(mouseX, mouseY);
      }

      // å¤„ç†è§¦æ‘¸å¼€å§‹äº‹ä»¶
      function handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          const touchX = touch.clientX - rect.left;
          const touchY = touch.clientY - rect.top;

          isDragging = true;
          updateAngle(touchX, touchY);
        }
      }

      // å¤„ç†è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
      function handleTouchMove(e) {
        e.preventDefault();
        if (!isDragging || e.touches.length !== 1) return;

        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        const touchY = touch.clientY - rect.top;

        updateAngle(touchX, touchY);
      }

      // æ›´æ–°è§’åº¦
      function updateAngle(x, y) {
        // è®¡ç®—ç›¸å¯¹äºåŸç‚¹çš„ä½ç½®
        const relX = x - centerX;
        const relY = centerY - y; // æ³¨æ„yåæ ‡åè½¬

        // è®¡ç®—æ–°è§’åº¦
        let newAngle = Math.atan2(relY, relX);

        // ç¡®ä¿è§’åº¦ä¸ºæ­£å€¼ï¼ˆ0åˆ°2Ï€ï¼‰
        if (newAngle < 0) {
          newAngle += 2 * Math.PI;
        }

        angle = newAngle;

        // é‡æ–°ç»˜åˆ¶åœºæ™¯
        drawScene();
        drawFunctionGraphs();
      }

      // å¯åŠ¨åº”ç”¨
      init();
    </script>
  </body>
</html>
